
> [!abstract] 6.4
> 
> # Passing Parameters

---
> [!quote] Concept
> 
> #### Pass by Value

```cpp
int func(int x)
{
    return 2 * x + 1;
}
```

When passing by value, a copy of the argument is made. Changes to the parameter inside the function do not affect the original variable.

**When to use:** When you only need to **read** the value of a **fundamental data type** (int, double, char, bool, etc.).


> [!quote] Concept
> 
> #### Pass by Constant Reference

```cpp
int countWords(const std::string& str)
{
    int result { 0 };
    for (char c : str) {
        if (c == ' ') result++;
    }
    return result + 1;  // Word count = spaces + 1
}
```

When passing by const reference, the function receives a reference to the original object but cannot modify it.

**When to use:** When you only need to **read** the value of a **class type** (std::string, std::vector, custom classes, etc.).

> [!hint] Best Practice
> 
> #### Pass by std::string_view

```cpp
#include <string_view>

int countWords(std::string_view strv)
{
    int result { 0 };
    for (char c : strv) {
        if (c == ' ') result++;
    }
    return result + 1;
}
```

In modern C++ (C++17+), `std::string_view` is preferred over `const std::string&` for string parameters that are only read.


> [!quote] Concept
> 
> #### Pass by Reference

```cpp
void modify(int& x1, int& x2, int& x3)
{
    x1 *= 2;
    x2 += 10;
    x3 = x1 + x2;
}

int main()
{
    int a { 5 }, b { 3 }, c { 0 };
    modify(a, b, c);  // a=10, b=13, c=23
}
```

When passing by reference, the function receives a reference to the original object and can modify it.

**When to use:** When you need to **modify** the value of parameters through the function.

> [!info] Additional Information
> 
> #### Pass by Pointer (Not Preferred)

```cpp
void modify(int* ptr)
{
    if (ptr) {           // Always null-check!
        *ptr = 10;
    }
}

int main()
{
    int x { 5 };
    modify(&x);          // x becomes 10
    modify(nullptr);     // Safe: null check prevents crash
}
```

Passing by pointer allows the function to receive a memory address. The pointer can be null.

**When to use:** Only for **optional parameters** where `nullptr` is a meaningful and valid input representing "no value".

**Modern alternative:** Use `std::optional` for optional parameters instead of pointers (see [[6.5 - Notes]]).