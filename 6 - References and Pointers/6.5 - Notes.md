
> [!abstract] 6.5
> 
> # Returning Values

> [!quote] Concept
> 
> #### Return by Value

```cpp
int func()
{
    int result { 42 };
    return result;
}

std::string getName()
{
    std::string name { "Alice" };
    return name;  // Modern C++ optimizes this
}
```

Returning by value means the function returns a copy of the object. This is the most common and preferred return method.

**When to use:** This is the **default choice** for most functions. Modern C++ compilers use return value optimization (RVO) and move semantics to make this efficient even for large objects.


> [!quote] Concept
> 
> #### Return by Reference

```cpp
// SAFE: Static/global variable
const std::string& getName()
{
    static std::string s_name { "Alice" };
    return s_name;  // Safe: static variable persists
}

// SAFE: Class member
class Person {
    std::string m_name;
public:
    const std::string& getName() const {
        return m_name;  // Safe: member persists with object
    }
};
```

Returning by reference returns an alias to an existing object rather than a copy.

**When to use:** Occasionally, when returning a reference to a static variable, global variable, or class member that persists beyond the function call.

> [!warning] Warning
> 
> #### Dangling References

```cpp
// DANGEROUS: Local variable
const int& bad()
{
    int local { 5 };
    return local;  // DANGER: local is destroyed when function ends!
}

int main()
{
    const int& ref = bad();  // Dangling reference!
    std::cout << ref;        // Undefined behavior
}
```

**Never return a reference to a local variable.** Local variables are destroyed when the function ends, leaving a <u><strong style="color:#dab1da">dangling reference</strong></u> that points to invalid memory.

> [!quote] Concept
> 
> #### Return by Pointer

```cpp
int* find(int arr[], int size, int target)
{
    for (int i = 0; i < size; ++i) {
        if (arr[i] == target)
            return &arr[i];  // Found: return address
    }
    return nullptr;          // Not found: return null
}

int main()
{
    int arr[5] { 10, 20, 30, 40, 50 };
    int* result = find(arr, 5, 30);
    
    if (result) {            // Always check for null!
        std::cout << *result;
    } else {
        std::cout << "Not found";
    }
}
```

Returning by pointer allows the function to return `nullptr` to indicate "no value" or "not found".

**When to use:** Occasionally, when you need to indicate that a result might not exist, and the pointer points to memory that persists beyond the function (like array elements, static variables, or dynamically allocated memory).

> [!hint] Best Practice
> 
> #### Type-Safe Optional (Preferred Modern Approach)

```cpp
#include <optional>
#include <iostream>

std::optional<int> divide(int a, int b)
{
    if (b == 0) return std::nullopt;  // No value
    return a / b;                     // Has value
}

std::optional<int> find(const std::vector<int>& vec, int target)
{
    for (int val : vec) {
        if (val == target) return val;
    }
    return std::nullopt;  // Not found
}

int main()
{
    auto result = divide(100, 10);
    
    if (result.has_value()) {
        std::cout << result.value();  // or: *result
    } else {
        std::cout << "No value";
    }
    
    // More concise with value_or
    std::cout << divide(10, 0).value_or(-1);  // Prints -1
}
```

`std::optional<T>` is a modern C++ (C++17+) type-safe alternative to nullable pointers.

**When to use:** When a function might not have a result (instead of returning a pointer that could be null).
