> [!abstract] 6.2
> 
> # Pointers

> [!quote] Concept
> 
> #### Pointer

A <u><strong style="color:#dab1da">pointer</strong></u> is an object that holds a memory address as its value. Unlike references, pointers are objects themselves that can be reassigned and can be null.

```cpp
int x { 5 };
int* ptr { &x };           // & gets address of x
std::cout << ptr;          // Prints address (e.g., 0x7ffd5c4b2a4c)
std::cout << *ptr;         // Dereferences ptr, prints value of x (5)
*ptr = 10;                 // Changes the value at that address (x becomes 10)
(*ptr)++;                  // Increment value at address (x becomes 11)
```

The <u><strong style="color:#dab1da">address-of operator</strong></u> `&` returns the memory address of an object. The <u><strong style="color:#dab1da">dereference operator</strong></u> `*` accesses the value at the address stored in the pointer.

> [!fact] Important
> 
> #### Null Pointers

A <u><strong style="color:#dab1da">null pointer</strong></u> is a pointer that doesn't point to any valid memory address. Dereferencing a null pointer causes undefined behavior (usually a crash).

```cpp
int* ptr {};               // Preferred: value initialization to nullptr
int* ptr { nullptr };      // Explicit null pointer
int* ptr { 0 };           // Old style, avoid

if (ptr)                   // Check before dereferencing
    std::cout << *ptr;     // Safe: only dereference if not null
```

**Always initialize pointers and check for null before dereferencing!**

> [!quote] Concept
> 
> #### Pointer Types

Pointers can be combined with `const` in different ways to control what can be changed:

```cpp
int value { 5 };

const int* ptr1 { &value };      // Pointer to constant
// *ptr1 = 10;                   // Error: can't change value through ptr1
ptr1 = nullptr;                  // OK: can change where ptr1 points

int* const ptr2 { &value };      // Const pointer
*ptr2 = 10;                      // OK: can change value
// ptr2 = nullptr;               // Error: can't change where ptr2 points

const int* const ptr3 { &value }; // Const pointer to constant
// *ptr3 = 10;                   // Error: can't change value
// ptr3 = nullptr;               // Error: can't change where it points
```

**Tip:** Read right-to-left: `const int*` is "pointer to const int", `int* const` is "const pointer to int"

> [!warning] Warning
> 
> #### Pointer Arithmetic

```cpp
int arr[5] { 1, 2, 3, 4, 5 };
int* ptr { arr };
ptr++;                     // Points to next element (dangerous!)
```

**Pointer arithmetic is dangerous and error-prone.** Incrementing or decrementing pointers moves them by the size of the pointed-to type. Going out of array bounds causes undefined behavior. Use with extreme caution or prefer safer alternatives like iterators.