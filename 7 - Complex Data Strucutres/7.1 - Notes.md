
> [!abstract] 7.1
> # Fixed-size Arrays (std::array)

> [!quote] Concept
> 
> #### What is std::array?

<u><strong style="color:#dab1da">std::array</strong></u> is a <u><strong style="color:#dab1da">fixed-size array</strong></u> container whose length must be known at compile-time and cannot change. Unlike std::vector, std::array has full <u><strong style="color:#dab1da">constexpr</strong></u> support, making it ideal for compile-time arrays.

```cpp
#include <array>

std::array<int, 5> a{};              // std::array of 5 ints
constexpr std::array<int, 5> b{};    // constexpr array (preferred when possible)
```

**Use std::array for constexpr arrays, and std::vector for non-constexpr arrays.**

> [!fact] Important
> 
> #### Defining and Initializing

std::array is an <u><strong style="color:#dab1da">aggregate</strong></u> with no constructors, initialized using <u><strong style="color:#dab1da">aggregate initialization</strong></u>:

```cpp
std::array<int, 5> a;           // Default init (elements uninitialized)
std::array<int, 5> b{};         // Value init (elements zero-initialized) - preferred
std::array<int, 5> c{ 1, 2 };   // List init (remaining elements value-initialized)

// CTAD (C++17) - compiler deduces type and length
constexpr std::array d{ 1, 2, 3, 4, 5 };  // deduces std::array<int, 5>
```

The length must be a <u><strong style="color:#dab1da">constant expression</strong></u> (literal, constexpr variable, or enumerator).

> [!fact] Important
> 
> #### Accessing Elements

**operator[]** - No bounds checking (fast, undefined behavior if out of bounds):

```cpp
constexpr std::array arr{ 2, 3, 5, 7, 11 };
std::cout << arr[3];  // 7
```

**at()** - Runtime bounds checking (throws exception if out of bounds):

```cpp
std::cout << arr.at(3);  // 7, checked at runtime
```

**std::get<>()** - Compile-time bounds checking (for constexpr indices):

```cpp
std::cout << std::get<3>(arr);   // 7, checked at compile-time
std::cout << std::get<10>(arr);  // Compile error
```

> [!hint] Best Practice
> 
> #### Using size_t for Length and Indices

Like std::vector, std::array uses <u><strong style="color:#dab1da">std::size_t</strong></u> (unsigned type) for length and indices. This is defined as the nested type <u><strong style="color:#dab1da">size_type</strong></u>.

```cpp
constexpr std::array arr{ 1, 2, 3, 4, 5 };

arr.size();           // Returns std::size_t (unsigned)
std::size(arr);       // C++17, returns std::size_t
std::ssize(arr);      // C++20, returns signed type (std::ptrdiff_t)
```

**Key advantage with std::array:** All three functions return <u><strong style="color:#dab1da">constexpr</strong></u> values. This means constexpr signed values convert to std::size_t without narrowing:

```cpp
constexpr int index{ 3 };
std::cout << arr[index];  // OK: constexpr intâ†’size_t is non-narrowing

int i{ 3 };  // non-constexpr
std::cout << arr[i];  // Warning: runtime sign conversion (narrowing)
```

For non-constexpr signed indices, use std::size_t for the loop variable or use range-based for loops to avoid indexing altogether.


> [!quote] Concept
> 
> #### Iterating Through Arrays

**Index-based loops** use subscripts to access elements:

```cpp
constexpr std::array arr{ 1, 2, 3, 4, 5 };

for (std::size_t i{ 0 }; i < arr.size(); ++i)
    std::cout << arr[i] << ' ';
```

**Range-based for loops** iterate without explicit indexing:

```cpp
for (auto i : arr)
    std::cout << i << ' ';

// For complex data types
for (const auto& element : arr)  // const reference avoids copies
    std::cout << element << ' ';
```

Range-based for loops are preferred when you don't need the index, as they avoid sign conversion issues and off-by-one errors.

> [!hint] Best Practice
> 
> #### Passing to Functions

Always pass std::array by <u><strong style="color:#dab1da">const reference</strong></u>. Use function templates for generic element types and lengths:

```cpp
// Template for any element type and length
template <typename T, std::size_t N>
void print(const std::array<T, N>& arr)
{
    for (const auto& element : arr)
        std::cout << element << ' ';
}

// C++20: Use auto for non-type template parameter
template <typename T, auto N>
void print(const std::array<T, N>& arr) { /* ... */ }
```

**static_assert** on length for compile-time validation:

```cpp
template <typename T, std::size_t N>
void printElement3(const std::array<T, N>& arr)
{
    static_assert(N > 3);  // Ensure array has at least 4 elements
    std::cout << arr[3];
}
```

> [!quote] Concept
> 
> #### Returning std::array

Unlike std::vector, std::array is not move-capable and will be copied when returned.

**Return by value** (acceptable for small arrays with cheap-to-copy elements):

```cpp
template <typename T, std::size_t N>
std::array<T, N> createArray() {
    std::array<T, N> arr{};
    // ... populate arr
    return arr;  // Copied
}
```

**Use out parameter** (for expensive-to-copy cases):

```cpp
template <typename T, std::size_t N>
void fillArray(std::array<T, N>& arr) {  // Pass by non-const reference
    // ... modify arr
}
```

**Consider std::vector** if returning non-constexpr arrays (move-capable, no copy).

> [!info] Additional Information
> 
> #### Arrays of References

Arrays cannot contain references. Use <u><strong style="color:#dab1da">std::reference_wrapper</strong></u> as a workaround:

```cpp
#include <functional>

int x{ 1 }, y{ 2 }, z{ 3 };
std::array<std::reference_wrapper<int>, 3> refs{ x, y, z };

refs[1].get() = 5;  // Modify through reference (use .get() to disambiguate)
std::cout << refs[1];  // Prints 5 (implicitly converts to int&)
```

Use **std::ref()** and **std::cref()** as shortcuts:

```cpp
auto ref{ std::ref(x) };    // std::reference_wrapper<int>
auto cref{ std::cref(x) };  // std::reference_wrapper<const int>
```

> [!info] Additional Information
> 
> #### Multidimensional Arrays

Create 2D arrays by nesting std::array (requires double braces):

```cpp
std::array<std::array<int, 4>, 3> arr{{  // 3 rows, 4 columns
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 }
}};

std::cout << arr[1][2];  // Access element at row 1, column 2
```

**Alias template** improves readability:

```cpp
template <typename T, std::size_t Row, std::size_t Col>
using Array2d = std::array<std::array<T, Col>, Row>;

Array2d<int, 3, 4> arr{{  // Much cleaner
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 }
}};
```

**C++23: std::mdspan** provides a better multidimensional interface for contiguous data.

