> [!abstract] 7.4
> # Stack and Queue

C++ STL provides three container adapters for restricted access patterns:

```cpp
#include <stack>
#include <queue>

stack<int> st;           // LIFO: Last In, First Out
queue<int> q;            // FIFO: First In, First Out
priority_queue<int> pq;  // Heap-based: Priority order
```

> [!quote] Concept
> 
> #### Container Adapters

<u><strong style="color:#dab1da">Container adapters</strong></u> are interfaces that restrict access to underlying containers. They don't provide iterators—only specific access points.

**Underlying containers:**

- Stack & Queue: Use `deque` by default
- Priority Queue: Uses `vector` by default

> [!quote] Concept
> 
> #### Stack Operations (LIFO)

Elements are added and removed from the **same end** (top).

```cpp
stack<int> st;

// Adding elements
st.push(10);             // {10}
st.push(20);             // {10, 20}
st.push(30);             // {10, 20, 30} ← top

// Accessing
cout << st.top();        // 30 (most recent)

// Removing
st.pop();                // Removes 30
cout << st.top();        // 20

// Checking state
st.empty();              // false
st.size();               // 2
```

**Time Complexity:** All operations O(1)

> [!hint] Best Practice
> 
> #### Pseudo-Traversal Pattern

Since stacks/queues don't provide iterators, copy them to traverse:

```cpp
stack<int> temp(st);     // Create copy
while (!temp.empty()) {
    cout << temp.top() << " ";
    temp.pop();          // Doesn't affect original
}
```

> [!quote] Concept
> 
> #### Queue Operations (FIFO)

Elements are added at the **back** and removed from the **front**.

```cpp
queue<int> q;

// Adding elements (enqueue)
q.push(10);              // {10}
q.push(20);              // {10, 20}
q.push(30);              // {10, 20, 30}
                         //  ↑front    ↑back

// Accessing
cout << q.front();       // 10 (oldest)
cout << q.back();        // 30 (newest)

// Removing (dequeue)
q.pop();                 // Removes 10
cout << q.front();       // 20

// Checking state
q.empty();               // false
q.size();                // 2
```

**Time Complexity:** All operations O(1)

> [!quote] Concept
> 
> #### Priority Queue Operations

Elements are removed based on **priority** (not insertion order). Uses a <u><strong style="color:#dab1da">heap</strong></u> internally.

**Max-Heap (default):**

```cpp
priority_queue<int> pq;  // Largest element has highest priority

pq.push(30);
pq.push(10);
pq.push(40);
pq.push(20);

cout << pq.top();        // 40 (largest)
pq.pop();
cout << pq.top();        // 30 (next largest)
```

**Min-Heap:**

```cpp
priority_queue<int, vector<int>, greater<int>> pq;  // Smallest first

pq.push(30);
pq.push(10);
pq.push(40);

cout << pq.top();        // 10 (smallest)
```

**Time Complexity:**

- `push()`, `pop()`: **O(log n)**
- `top()`: **O(1)**

> [!info] Additional Information
> 
> #### Custom Priority

Define custom comparators for complex types:

```cpp
struct Task {
    string name;
    int priority;
};

// Lower priority value = higher importance
auto cmp = [](Task a, Task b) { return a.priority > b.priority; };
priority_queue<Task, vector<Task>, decltype(cmp)> pq(cmp);
```

> [!fact] Important
> 
> #### Function Reference

|Function|Stack|Queue|Priority Queue|
|---|---|---|---|
|Add|`push()`|`push()`|`push()`|
|Remove|`pop()`|`pop()`|`pop()`|
|Access|`top()`|`front()`, `back()`|`top()`|
|Check empty|`empty()`|`empty()`|`empty()`|
|Get size|`size()`|`size()`|`size()`|

> [!warning] Warning
> 
> #### Common Mistakes

**No iterators available:**

```cpp
// ✗ WRONG - no iterators
for (auto x : st) { }         // Compilation error!

// ✓ CORRECT - use copy to traverse
stack<int> temp(st);
while (!temp.empty()) {
    process(temp.top());
    temp.pop();
}
```

**`pop()` returns void:**

```cpp
// ✗ WRONG
int x = st.pop();             // Error: pop() returns void

// ✓ CORRECT
int x = st.top();             // Get value first
st.pop();                     // Then remove
```

**Accessing empty container:**

```cpp
// ✗ WRONG - undefined behavior
if (st.empty())
    cout << st.top();         // Crash!

// ✓ CORRECT - check before access
if (!st.empty())
    cout << st.top();
```

> [!info] Additional Information
> 
> #### When to Use

**Stack:**

- Function call management (recursion)
- Undo/redo operations
- Expression evaluation
- Backtracking algorithms

**Queue:**

- Task scheduling (process queue)
- Breadth-first search (BFS)
- Buffer management
- Print spooler

**Priority Queue:**

- Dijkstra's shortest path
- Huffman coding
- Event-driven simulation
- A* pathfinding
- Job scheduling with priorities