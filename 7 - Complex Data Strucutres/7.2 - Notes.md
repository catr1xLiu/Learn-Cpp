
> [!abstract] 7.2
> # Dynamic Arrays (std::vector)

> [!quote] Concept
> 
> #### Vectors

<u><strong style="color:#dab1da">std::vector</strong></u> is a <u><strong style="color:#dab1da">dynamic array</strong></u> from the C++ standard library that can change size after creation. Unlike fixed-size arrays (std::array, C-style arrays), vectors can grow and shrink at runtime.

```cpp
#include <vector>

std::vector<int> empty{};              // Empty vector
std::vector primes{ 2, 3, 5, 7, 11 };  // CTAD deduces std::vector<int>
```

> [!fact] Important
> 
> #### Constructing a Vector

The <u><strong style="color:#dab1da">list constructor</strong></u> initializes a vector with specific values using an initializer list:

```cpp
std::vector<int> values{ 1, 2, 3, 4 };  // List constructor: 4 elements with values
```

To create a vector with a specific length (elements <u><strong style="color:#dab1da">value-initialized</strong></u> to 0 for ints), use direct initialization:

```cpp
std::vector<int> data(10);     // 10 elements, all initialized to 0
std::vector<int> wrong{ 10 };  // 1 element with value 10 (list constructor!)
```

**Critical:** Non-empty `{}` always prefers the list constructor. Use `()` for size-based construction.

> [!fact] Important
> 
> #### Accessing Elements

<u><strong style="color:#dab1da">Subscript operator []</strong></u> accesses elements by index (0-based, no bounds checking):

```cpp
std::vector data{ 10, 20, 30 };
std::cout << data[0];  // 10 (first element)
std::cout << data[2];  // 30 (third element)
```

The <u><strong style="color:#dab1da">at() member function</strong></u> performs runtime bounds checking and throws an exception for invalid indices:

```cpp
data.at(5);  // Throws std::out_of_range
```


> [!info] Additional Information
> 
> #### Stack Operations

Vectors support efficient <u><strong style="color:#dab1da">stack operations</strong></u> for adding/removing elements at the end:

```cpp
std::vector<int> stack{};

stack.push_back(1);     // Add element to end
stack.push_back(2);     // Stack: [1, 2]
int top = stack.back(); // Get last element (2)
stack.pop_back();       // Remove last element, Stack: [1]
```

**emplace_back()** is more efficient when creating temporary objects directly in the vector:

```cpp
stack.push_back({args});  // Creates temp, then copies
stack.emplace_back(args); // Constructs directly in vector (no copy)
```

> [!quote] Concept
> 
> #### Iterating Through Vectors

**Index-based loops** access elements by position:

```cpp
std::vector data{ 10, 20, 30 };

for (std::size_t i{ 0 }; i < data.size(); ++i)
    std::cout << data[i] << ' ';
```

**Range-based for loops** provide cleaner iteration:

```cpp
for (const auto& i : data)
    std::cout << i << ' ';
    
// For complex data types
for (const auto& element : data) // const ref to avoid copying
    std::cout << element << ' ';
```

Range-based for loops eliminate indexing errors and work automatically with any container length.

> [!info] Additional Information
> 
> #### Capacity and Reserving Space

<u><strong style="color:#dab1da">Length</strong></u> is the number of elements currently in use. <u><strong style="color:#dab1da">Capacity</strong></u> is how many elements are allocated in memory.

```cpp
std::vector data{ 1, 2, 3 };
data.size();      // Length: 3
data.capacity();  // Capacity: 3
```

<u><strong style="color:#dab1da">Reallocation</strong></u> (copying all elements to new memory) occurs when capacity is insufficient. This is expensive.

**resize()** changes both length and capacity:

```cpp
data.resize(5);  // Length: 5, Capacity: 5 (new elements value-initialized)
// data = {1, 2, 3, 0, 0}
```

**reserve()** changes only capacity (for stack operations):

```cpp
std::vector<int> stack{};
stack.reserve(100);  // Capacity: 100, Length: 0 (no reallocation when pushing)
```

> [!hint] Best Practice
> 
> #### Passing Vectors to Functions

Always pass vectors by <u><strong style="color:#dab1da">const reference</strong></u> to avoid expensive copies:

```cpp
void print(const std::vector<int>& arr)  // Pass by const reference
{
    for (std::size_t i{ 0 }; i < arr.size(); ++i)
        std::cout << arr[i] << ' ';
}
```

For generic functions accepting any element type, use function templates:

```cpp
template <typename T>
void print(const std::vector<T>& arr)  // Works with any type
{
    for (const auto& element : arr)
        std::cout << element << ' ';
}
```

> [!quote] Concept
> 
> #### Returning Vectors (Move Semantics)

Vectors can be efficiently returned by value using <u><strong style="color:#dab1da">move semantics</strong></u>. Instead of copying, ownership of the vector's data is transferred (typically just a few pointer assignments):

```cpp
std::vector<int> createVector()
{
    std::vector data{ 1, 2, 3 };
    return data;  // Moved, not copied (efficient)
}

std::vector result{ createVector() };  // Receives moved data
```

**Move semantics** automatically applies when returning by value. The returned object (an rvalue) transfers its data instead of copying it.