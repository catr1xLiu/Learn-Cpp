> [!abstract] 7.3
> # Linked List and Iterators

A <u><strong style="color:#dab1da">list</strong></u> in C++ is a sequence container implemented as a <u><strong style="color:#dab1da">doubly linked list</strong></u>. Data is stored in **non-contiguous memory**, enabling fast insertion and deletion at any position.

```cpp
#include <list>
#include <algorithm>  // for find()

list<int> myList;     // Create empty list
list<int> l = {1, 2, 3};  // Initialize with values
```

> [!quote] Concept
> 
> #### Doubly Linked List

- Each node maintains pointers to **both** previous and next elements
- Supports bidirectional traversal
- No random access (unlike vectors)
- Fast operations at **both ends**: O(1)

> [!info] Additional Information
> 
> #### When to Use List vs Vector

**Use `list` when:**

- Frequent insertions/deletions in middle
- No need for random access by index

**Use `vector` when:**

- Need fast random access
- Mostly adding/removing at end

> [!quote] Concept
> 
> #### Adding & Removing Elements

**Adding Elements:**

```cpp
list<int> l = {3, 2};

l.push_back(5);      // Add to end → {3, 2, 5}
l.push_front(1);     // Add to beginning → {1, 3, 2, 5}

// Insert at specific position using iterator
auto it = l.begin();
advance(it, 2);      // Move iterator 2 positions
l.insert(it, 4);     // Insert before position → {1, 3, 4, 2, 5}
```

**Removing Elements:**

```cpp
list<int> l = {1, 3, 4, 2, 5};

l.pop_front();       // Remove first → {3, 4, 2, 5}
l.pop_back();        // Remove last → {3, 4, 2}

// Remove at specific position
auto it = l.begin();
advance(it, 1);
l.erase(it);         // Remove second element → {3, 2}

l.clear();           // Remove all elements
```

**Time Complexity:**

- `push_front()`, `push_back()`, `pop_front()`, `pop_back()`: **O(1)**
- `insert()`, `erase()`: **O(1)** if iterator known, **O(n)** to reach position

---

> [!quote] Concept
> 
> #### Accessing & Modifying Elements

Lists do **not support random access** (no `[]` operator). Use <u><strong style="color:#dab1da">iterators</strong></u> to reach elements.

**Accessing:**

```cpp
list<int> l = {1, 3, 4, 2, 5};

cout << l.front();              // First element: 1
cout << l.back();               // Last element: 5

auto it = next(l.begin(), 2);   // Get iterator to 3rd element
cout << *it;                    // Access value: 4
```

**Modifying:**

```cpp
list<int> l = {1, 3, 4, 2, 5};

l.front() = 11;                 // Change first → {11, 3, 4, 2, 5}

auto it = l.begin();
advance(it, 2);                 // Move to 3rd element
*it = 10;                       // Update value → {11, 3, 10, 2, 5}
```

**Time Complexity:**

- Access/Update: **O(1)** with iterator, **O(n)** to reach element

> [!hint] Best Practice
> 
> #### Iterator Functions

- `advance(it, n)`: Move iterator `n` positions (modifies `it`)
- `next(it, n)`: Returns new iterator `n` positions ahead (doesn't modify `it`)
- `prev(it, n)`: Returns new iterator `n` positions behind

---

> [!quote] Concept
> 
> #### Searching & Traversing with Iterators

**Finding Elements:**

```cpp
list<int> l = {1, 3, 4, 2, 5};

auto it = find(l.begin(), l.end(), 4);  // Returns iterator to 4

if (it != l.end())
    cout << "Found: " << *it;
else
    cout << "Not found";
```

**Traversing Forward:**

```cpp
// Range-based loop (preferred)
for (int val : l)
    cout << val << " ";

// Using iterators
for (auto it = l.begin(); it != l.end(); ++it)
    cout << *it << " ";
```

**Traversing Backward:**

```cpp
for (auto it = l.rbegin(); it != l.rend(); ++it)
    cout << *it << " ";
```

**Time Complexity:** **O(n)** for searching and traversal

> [!hint] Best Practice
> 
> #### Iterator Usage

- Always check if iterator equals `end()` before dereferencing
- Use `++it` (pre-increment) instead of `it++` for efficiency
- Prefer range-based loops when you don't need the iterator itself

---

> [!fact] Important
> 
> #### Essential Functions

|Function|Description|Time|
|---|---|---|
|`size()`|Returns number of elements|O(1)|
|`empty()`|Checks if list is empty|O(1)|
|`begin()` / `end()`|Forward iterators|O(1)|
|`rbegin()` / `rend()`|Reverse iterators|O(1)|
|`front()` / `back()`|Access first/last element|O(1)|

> [!warning] Warning
> 
> #### Common Pitfalls

- **No random access**: Cannot use `l[i]` to access elements
- **Iterator invalidation**: `erase()` invalidates the iterator to the erased element (but not others)
- **Traversal cost**: Reaching middle elements requires O(n) traversal

```cpp
// ✗ Wrong - no operator[]
list<int> l = {1, 2, 3};
cout << l[1];  // Compilation error!

// ✓ Correct
auto it = next(l.begin(), 1);
cout << *it;
```